# This is here temporarily because we don't have a network yet.
nspec    integer   2

# This file contains the runtime parameters for all SMC problems.  It 
# is parsed by write_probin.py and merged with probin.template to produce
# the probin.f90 at compile time.
#
# problem-specific runtime parameters should be defined in a _parameters
# file in the problem directory.


#-----------------------------------------------------------------------------
# category: general SMC
#-----------------------------------------------------------------------------

# General verbosity
verbose                             integer            0                   

# use the MPI alltoallv call
do_alltoallv                        logical            .false.             

# Verbosity of the knapscak processor-to-grid algorithm.
the_knapsack_verbosity              logical            .false.             

# job name printed in output
job_name                            character          ""                  

# Call a parallel\_barrier before each of the simple timers we have coded
# in advance.f90.  Might cause a very slight overall performance hit.
barrier_timers                      logical            .false.


#-----------------------------------------------------------------------------
# category: problem initialization
#-----------------------------------------------------------------------------

# ...


#-----------------------------------------------------------------------------
# category: timestepping 
#-----------------------------------------------------------------------------

# Time-stepping scheme (1=RK3, 2=SDC, 3=PFASST)
advance_method                      integer           1

# simulation stop time
stop_time                           real               -1.d0               

# Maximum number of steps in the simulation.
max_step                            integer            1                   

# CFL factor to use in the computation of the advection timestep constraint
cflfac                              real               0.5d0                 

# the multiplicative factor ($\le 1$) to reduce the initial timestep as 
# computed by the various timestep estimators
init_shrink                         real               1.d0                 

# the minimum allowed timestep -- we abort if dt drops below this value
small_dt                            real               1.d-30

# The maximum scale factor that the time step is allowed to grow by per 
# time step.
max_dt_growth                       real               1.1d0

# This is the maximum dt that is allowed
max_dt                              real               1.0d33

# Fix the time step.  If -1.0, then use the standard time step.
fixed_dt                            real               -1.0d0              


#-----------------------------------------------------------------------------
# category: grid
#-----------------------------------------------------------------------------

# physical coordinates of lo-x corner of problem domain
prob_lo_x                           real               ZERO                

# physical coordinates of lo-y corner of problem domain
prob_lo_y                           real               ZERO                

# physical coordinates of lo-z corner of problem domain
prob_lo_z                           real               ZERO                

# physical coordinates of hi-x corner of problem domain
prob_hi_x                           real               1.d0                    

# physical coordinates of hi-y corner of problem domain
prob_hi_y                           real               1.d0                    

# physical coordinates of hi-z corner of problem domain
prob_hi_z                           real               1.d0                    


# $-x$ boundary condition
bcx_lo                              integer            SLIP_WALL           

# $+x$ boundary condition (valid values are listed in {\tt  boxlib/bc.f90})
bcx_hi                              integer            SLIP_WALL           

# $-y$ boundary condition
bcy_lo                              integer            SLIP_WALL           

# $+y$ boundary condition
bcy_hi                              integer            SLIP_WALL           

# $-z$ boundary condition
bcz_lo                              integer            SLIP_WALL           

# $+z$ boundary condition
bcz_hi                              integer            SLIP_WALL           

# $-x$ boundary condition name---if this is set, it overrides the integer
# value set through {\tt bcx\_lo}
xlo_boundary_type                   character          ""

# $+x$ boundary condition name---if this is set, it overrides the integer
# value set through {\tt bcx\_hi}
xhi_boundary_type                   character          ""

# $-y$ boundary condition name---if this is set, it overrides the integer
# value set through {\tt bcy\_lo}
ylo_boundary_type                   character          ""

# $+y$ boundary condition name---if this is set, it overrides the integer
# value set through {\tt bcy\_hi}
yhi_boundary_type                   character          ""

# $-z$ boundary condition name---if this is set, it overrides the integer
# value set through {\tt bcz\_lo}
zlo_boundary_type                   character          ""

# $+z$ boundary condition name---if this is set, it overrides the integer
# value set through {\tt bcz\_hi}
zhi_boundary_type                   character          ""

# dimensionality (valid values are 2 or 3)
dm_in                               integer            3

# The largest grid size that will be created using make\_new\_grids.
max_grid_size                       integer            64                  

# Change the max grid size on restart 
change_max_grid_size                logical            .false.  

# Number of cells in the x-direction
n_cellx                             integer            -1                     

# Number of cells in the y-direction
n_celly                             integer            -1                     

# Number of cells in the z-direction
n_cellz                             integer            -1                    

# When assigning processors for grids, this determines whether we use 
# the sfc algorithm or knapsack algorithm.  If the total number of grids 
# divided by the number of processors is greater than this number, use sfc.
the_sfc_threshold                   integer            5                   

the_layout_verbosity                integer            0                   

#  Number of boxassoc layouts we keep in memory to avoid having to 
# recompute the boxassoc, which is computationally expensive.
the_copy_cache_max                  integer            25          

# The minimum size on a side for a grid created using make\_new\_grids.
minwidth                            integer            8                     

# grids must be an integer multiple of this number, if possible
blocking_factor                     integer            8                    


#-----------------------------------------------------------------------------
# category: output
#-----------------------------------------------------------------------------

# plot interval
plot_int                            integer            0                   

# rather than use a plot interval, plot a file after the solution has 
# advanced past plot\_deltat in time
plot_deltat                         real               -1.d0                 

# Number of timesteps between writing a checkpoint file
chk_int                             integer            0                   

# plot species and omegadot in plotfile
plot_spec                           logical            .true.              

# plot omegadot in plotfile 
plot_omegadot                       logical            .true.              

# prefix to use in plotfile file names
plot_base_name                      character          "plt"               

# prefix to use in checkpoint file names
check_base_name                     character          "chk"               

# If lUsingNFiles = .true., use this many processors to write checkpoint 
# and plotfiles.  Fortran has the unfortunate feature of each processor 
# only being able to write out 1-2GB each without crashing.
nOutFiles                           integer            64                  

# If .true., use nOutFiles processors to write checkpoint and plotfiles.  
# Fortran has the unfortunate feature of each processor only being able 
# to write out 1-2GB each without crashing.
lUsingNFiles                        logical            .true.              

# store the state data in single precision
single_prec_plotfiles               logical            .false.             

# create a field in the plotfile storing the processor number for each zone
plot_processors                     logical            .false.


#-----------------------------------------------------------------------------
# category: algorithm initialization
#-----------------------------------------------------------------------------

# which file to restart from.  -1 means do not restart
restart                             integer            -1                  

